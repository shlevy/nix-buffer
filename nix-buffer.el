;;; nix-buffer.el --- Command for setting up buffer environments with nix

;; Coypright (C) 2016 Shea Levy

;; Author: Shea Levy
;; URL: https://github.com/shlevy/nix-buffer/tree/master/
;; Version: 1.0
;; Package-Requires: ((f "0.17.3") (emacs "24.4"))

;;; Commentary:

;; This package provides 'nix-buffer-enter', to modify your buffer
;; according to a directory-local nix expression.

;; It may be desirable to run this before 'normal-mode' is called so
;; it affects all modes.

;;; Code:

(require 'f)
(require 'subr-x)

(defconst nix-buffer--directory-name
  (locate-user-emacs-file "nix-buffer"))

(defconst nix-buffer--trust-exprs-file
  (f-join nix-buffer--directory-name "trusted-exprs"))

(defvar nix-buffer--trusted-exprs
  (let ((tbl (ignore-errors
	       (with-temp-buffer
		 (insert-file-contents-literally
		  nix-buffer--trust-exprs-file)
		 (read (current-buffer))))))
    (if (hash-table-p tbl)
	tbl
      (make-hash-table :test 'equal))))

(defun nix-buffer-unload-function ()
  "Save state on unload."
  (ignore-errors (make-directory nix-buffer--directory-name t))
  (with-temp-buffer
    (prin1 nix-buffer--trusted-exprs (current-buffer))
    (write-region nil nil nix-buffer--trust-exprs-file))
  nil)

(defun nix-buffer--unique-filename (path)
  "Create a unix-safe filename from an entire path.
PATH the path to generate the name from."
  (replace-regexp-in-string "[|\\/]"
			    (lambda (str)
			      (if (equal str "/")
				  "|"
				(concat "\\\\" str)))
			    path))

(defun nix-buffer--nix-build (root expr-file)
  "Do the nix build.
ROOT the path we started from.

EXPR-FILE The file containing the nix expression to build."
  (let ((state-dir (f-join nix-buffer--directory-name
			   (nix-buffer--unique-filename root))))
    (ignore-errors (make-directory state-dir t))
    (with-temp-buffer
      (let* ((stderr-file (make-temp-file "err"))
	     (res (call-process "nix-build"
				nil
				'(t stderr-file)
				nil
				"--arg"
				"root"
				root
				"--out-link"
				(f-join state-dir "result")
				expr-file)))
	(with-temp-buffer
	  (insert-file-contents-literally stderr-file)
	  (delete-file stderr-file)
	  (or (eq res 0) (error
			  "Build of %s failed with error output %s"
			  expr-file
			  (buffer-string))))
	(string-trim-right (buffer-string))))))

(defun nix-buffer--query-safety (expr-file lisp-file)
  "Ask the user whether to trust a Lisp file.
EXPR-FILE The nix expression leading to this file.

LISP-FILE The file in question."
  (let ((res (yes-or-no-p (concat expr-file
				  " resulted in unknown Lisp file "
				  lisp-file
				  "; trust it?"))))
    (puthash lisp-file res nix-buffer--trusted-exprs)
    res))

;;;###autoload
(defun nix-buffer-enter ()
  "Set up the buffer according to the directory-local nix expression.
Looks for dir-locals.nix upward from the current directory.  If found,
builds the derivation defined there with the 'root' arg set to the
current buffer file name or directory and evaluates the resulting
elisp if safe to do so.

Because in practice dir-locals.nix will always want to do things that
are unsafe in dir-locals.el (e.g. append to 'exec-path'), we don't
reuse that mechanism and instead just load the file as elisp.  Because
this allows arbitrary code execution, the first time we're asked to
load a particular store path we query the user to verify if it's safe
to load beforehand.

The Lisp code generated by dir-locals.nix should limit itself to
modifying buffer-local variables, but there is no actual enforcement
of this.  'setq-local' is your friend."
  (interactive)
  (let* ((root (or (buffer-file-name) default-directory))
	 (expr-dir (f-traverse-upwards
		     (lambda (path)
		       (f-exists? (f-expand
				   "dir-locals.nix"
				   path)))
		     root)))
    (and expr-dir
	 (let* ((expr-file (f-expand "dir-locals.nix" expr-dir))
		(result (nix-buffer--nix-build root expr-file)))
	   (when (or (gethash result nix-buffer--trusted-exprs)
		     (nix-buffer--query-safety expr-file result))
	     (load-file result))))))

(add-hook 'kill-emacs-hook 'nix-buffer-unload-function)

(provide 'nix-buffer)

;;; nix-buffer.el ends here
